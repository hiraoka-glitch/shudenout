import { NextRequest, NextResponse } from 'next/server';
import { todayTomorrowJST } from '@/lib/date';
import { fetchCandidates, checkVacancy } from '@/lib/providers/rakuten';
import { mapVacantJsonToHotels } from '@/lib/providers/rakuten-utils';

// Force dynamic rendering and use Node.js runtime
export const runtime = 'nodejs';
export const dynamic = 'force-dynamic';

// ãƒ›ãƒ†ãƒ«å‹å®šç¾©
interface Hotel {
  id: string;
  name: string;
  price: number;
  rating?: number;
  imageUrl: string;
  affiliateUrl: string;
  area: string;
  nearest: string;
  amenities: string[];
  latitude?: number;
  longitude?: number;
  distanceKm?: number;
  walkingTimeMinutes?: number;
  isSameDayAvailable: boolean;
}

// ã‚¨ãƒªã‚¢åº§æ¨™ãƒãƒƒãƒ”ãƒ³ã‚°ï¼ˆæ¨™æº–åŒ–ã•ã‚ŒãŸç·¯åº¦çµŒåº¦æ¤œç´¢ç”¨ï¼‰
const AREA_COORDINATES: Record<string, { lat: number; lng: number; name: string }> = {
  'shinjuku': { lat: 35.690921, lng: 139.700258, name: 'æ–°å®¿' },
  'shibuya': { lat: 35.6580, lng: 139.7016, name: 'æ¸‹è°·' },
  'ueno': { lat: 35.7141, lng: 139.7774, name: 'ä¸Šé‡' },
  'shinbashi': { lat: 35.6662, lng: 139.7580, name: 'æ–°æ©‹' },
  'ikebukuro': { lat: 35.7295, lng: 139.7109, name: 'æ± è¢‹' },
  'roppongi': { lat: 35.6627, lng: 139.7314, name: 'å…­æœ¬æœ¨' }
};

// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ¤œç´¢ä¸­å¿ƒï¼ˆæ–°å®¿é§…ï¼‰
const DEFAULT_SEARCH_CENTER = { lat: 35.690921, lng: 139.700258, name: 'æ–°å®¿é§…å‘¨è¾º' };

function jsonResponse(data: Record<string, unknown>, status: number = 200): NextResponse {
  const response = NextResponse.json(data, { status });
  response.headers.set('Cache-Control', 'no-store');
  return response;
}

export async function GET(request: NextRequest) {
  const startTime = Date.now();
  
  // çµ±ä¸€ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ã‚­ãƒ¼ãƒï¼ˆå¸¸ã«åŒã˜å½¢ã‚’ä¿è¨¼ï¼‰
  const createResponse = (
    items: Hotel[] = [],
    success: boolean = true,
    error: string | null = null,
    message: string | null = null,
    debugInfo: Record<string, unknown> | undefined = undefined,
    areaName: string = 'æ–°å®¿é§…å‘¨è¾º'
  ) => {
    try {
      const { today, tomorrow } = todayTomorrowJST();
      return {
        items: Array.isArray(items) ? items : [],
        paging: {
          total: Array.isArray(items) ? items.length : 0,
          page: 1,
          totalPages: 1,
          hasNext: false
        },
        isSample: false,
        fallback: false,
        searchParams: {
          area: areaName,
          checkinDate: today,
          checkoutDate: tomorrow,
          adultNum: 2,
          isVacantSearch: true
        },
        message,
        success,
        error,
        ...(debugInfo ? { debug: debugInfo } : {})
      };
    } catch (dateError) {
      console.error('âŒ Date creation error:', dateError);
      return {
        items: [],
        paging: { total: 0, page: 1, totalPages: 0, hasNext: false },
        isSample: false,
        fallback: false,
        searchParams: {
          area: areaName,
          checkinDate: '2025-08-30',
          checkoutDate: '2025-08-31',
          adultNum: 2,
          isVacantSearch: true
        },
        message,
        success,
        error
      };
    }
  };

  try {
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è§£æï¼ˆtry/catch ã§å®ˆã‚‹ï¼‰
    let areaParam = 'all';
    let priceMin: number | undefined;
    let priceMax: number | undefined;
    let amenities: string[] = [];
    let adultNum = 2;
    let isInspectMode = false;
    let searchParams: URLSearchParams;
    
    try {
      const url = new URL(request.url);
      searchParams = url.searchParams;
      areaParam = searchParams.get('area') || 'all';
      priceMin = searchParams.get('priceMin') ? parseInt(searchParams.get('priceMin')!) : undefined;
      priceMax = searchParams.get('priceMax') ? parseInt(searchParams.get('priceMax')!) : undefined;
      amenities = searchParams.get('amenities')?.split(',').filter(Boolean) || [];
      adultNum = Math.max(1, Math.min(4, parseInt(searchParams.get('adults') || '2')));
      isInspectMode = searchParams.get('inspect') === '1';
    } catch (parseError) {
      console.warn('âš ï¸ Parameter parsing error, using defaults:', parseError);
      // searchParamsãŒundefinedã®å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
      searchParams = new URLSearchParams();
    }
    
    // åº§æ¨™è§£æï¼ˆtry/catch ã§å®ˆã‚‹ï¼‰
    let searchCenter = DEFAULT_SEARCH_CENTER;
    let areaName = 'æ–°å®¿é§…å‘¨è¾º';
    
    try {
      const lat = searchParams.get('lat');
      const lng = searchParams.get('lng');
      
      if (lat && lng) {
        const latitude = parseFloat(lat);
        const longitude = parseFloat(lng);
        if (!isNaN(latitude) && !isNaN(longitude)) {
          searchCenter = { lat: latitude, lng: longitude, name: 'æŒ‡å®šåº§æ¨™å‘¨è¾º' };
          areaName = 'æŒ‡å®šåº§æ¨™å‘¨è¾º';
        }
      } else if (areaParam !== 'all' && AREA_COORDINATES[areaParam]) {
        searchCenter = AREA_COORDINATES[areaParam];
        areaName = searchCenter.name;
      }
    } catch (coordError) {
      console.warn('âš ï¸ Coordinate parsing error, using default:', coordError);
    }
    
    // å›ºå®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
    const radiusKm = 3.0;
    let today = '2025-08-30';
    let tomorrow = '2025-08-31';
    
    try {
      const dates = todayTomorrowJST();
      today = dates.today;
      tomorrow = dates.tomorrow;
    } catch (dateError) {
      console.warn('âš ï¸ Date parsing error, using fallback:', dateError);
    }
    
    // æ¨™æº–åŒ–ã•ã‚ŒãŸãƒªã‚¯ã‚¨ã‚¹ãƒˆæƒ…å ±ã‚’ãƒ­ã‚°å‡ºåŠ›
    const standardizedRequest = {
      originalArea: areaParam,
      resolvedAreaName: areaName,
      coordinates: { lat: searchCenter.lat, lng: searchCenter.lng },
      searchRadius: radiusKm,
      dates: { checkinDate: today, checkoutDate: tomorrow },
      guests: { adultNum, roomNum: 1 },
      priceRange: { minCharge: priceMin, maxCharge: priceMax },
      amenities,
      isInspectMode
    };
    
    console.log('ğŸ¨ Standardized Hotel Search Request:', standardizedRequest);
    
    // Stage 0: ç’°å¢ƒå¤‰æ•°ç¢ºèª
    const rakutenAppId = process.env.RAKUTEN_APP_ID;
    if (!rakutenAppId) {
      console.error('âŒ RAKUTEN_APP_ID not configured');
      return jsonResponse(createResponse(
        [],
        false,
        'Missing RAKUTEN_APP_ID',
        'APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚',
        isInspectMode ? { error: 'Missing RAKUTEN_APP_ID' } : undefined,
        areaName
      ));
    }

    console.log('ğŸ” Starting two-stage pipeline: candidates â†’ vacancy check...');
    
    // Stage 1: å€™è£œãƒ›ãƒ†ãƒ«å–å¾—ï¼ˆå®Œå…¨try/catchåŒ…å›²ï¼‰
    let hotels: Hotel[] = [];
    let debugInfo: Record<string, unknown> | undefined = undefined;

    try {
      const candidatesResult = await fetchCandidates({
        lat: searchCenter.lat,
        lng: searchCenter.lng,
        radius: radiusKm,
        areaCode: areaParam !== 'all' ? areaParam : undefined,
        rakutenAppId
      });

      const candidateNos = candidatesResult?.candidateNos || [];
      const candidateCount = candidateNos.length;
      const candidateDebugInfo = candidatesResult?.debugInfo || {};
      
      if (candidateCount === 0) {
        console.log('ğŸ“ No hotel candidates found in target area');
        
        // APIã‚¨ãƒ©ãƒ¼ã¨å€™è£œ0ä»¶ã‚’åŒºåˆ¥ã™ã‚‹
        const apiStatus = candidateDebugInfo.attempts?.[0]?.status || 0;
        if (apiStatus >= 400 || apiStatus === 0) {
          return jsonResponse(createResponse(
            [],
            false,
            `Candidate API error (status: ${apiStatus})`,
            'ãƒ›ãƒ†ãƒ«æ¤œç´¢APIã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã€å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
            isInspectMode ? {
              pipeline: 'two_stage',
              candidateSource: candidateDebugInfo.source,
              candidateParams: {
                url: candidateDebugInfo.url || 'unknown',
                paramsUsed: candidateDebugInfo.paramsUsed || {},
                elapsedMs: candidateDebugInfo.totalElapsedMs || 0,
                status: apiStatus,
                bodySnippetHead: candidateDebugInfo.attempts?.[0]?.bodySnippetHead || 'no data'
              },
              candidateCount: 0,
              vacancy: { chunkSize: 15, chunks: [] }
            } : undefined,
            areaName
          ));
        } else {
          return jsonResponse(createResponse(
            [],
            true,
            null,
            'å¯¾è±¡ã‚¨ãƒªã‚¢ã§æ–½è¨­ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚ã‚¨ãƒªã‚¢ã‚’å¤‰ãˆã¦ãŠè©¦ã—ãã ã•ã„ã€‚',
            isInspectMode ? {
              pipeline: 'two_stage',
              candidateSource: candidateDebugInfo.source,
              candidateParams: {
                url: candidateDebugInfo.url || 'unknown',
                paramsUsed: candidateDebugInfo.paramsUsed || {},
                elapsedMs: candidateDebugInfo.totalElapsedMs || 0,
                status: apiStatus,
                bodySnippetHead: candidateDebugInfo.attempts?.[0]?.bodySnippetHead || 'no data'
              },
              candidateCount: 0,
              vacancy: { chunkSize: 15, chunks: [] }
            } : undefined,
            areaName
          ));
        }
      }

      // Stage 2: ç©ºå®¤åˆ¤å®šï¼ˆå®Œå…¨try/catchåŒ…å›²ï¼‰
      try {
        const vacancyResult = await checkVacancy(candidateNos, {
          checkinDate: today,
          checkoutDate: tomorrow,
          adultNum,
          roomNum: 1,
          rakutenAppId
        });

        if (vacancyResult?.vacantHotels && vacancyResult.vacantHotels.length > 0) {
          // ç©ºå®¤ã‚ã‚Šãƒ›ãƒ†ãƒ«ã‚’å¤‰æ›ï¼ˆtry/catch ã§å®ˆã‚‹ï¼‰
          try {
            // vacancyResult.vacantHotelsã¯æ—¢ã«Rakuten JSONã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å½¢å¼
            const vacantJson = { hotels: vacancyResult.vacantHotels };
            hotels = mapVacantJsonToHotels(vacantJson);
            
            // ä¾¡æ ¼ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆtry/catch ã§å®ˆã‚‹ï¼‰
            try {
              if (priceMin !== undefined || priceMax !== undefined) {
                hotels = hotels.filter(hotel => {
                  if (priceMin !== undefined && hotel.price < priceMin) return false;
                  if (priceMax !== undefined && hotel.price > priceMax) return false;
                  return true;
                });
              }
            } catch (priceFilterError) {
              console.warn('âš ï¸ Price filtering error:', priceFilterError);
            }

            // ã‚¢ãƒ¡ãƒ‹ãƒ†ã‚£ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°ï¼ˆtry/catch ã§å®ˆã‚‹ï¼‰
            try {
              if (amenities.length > 0) {
                hotels = hotels.filter(hotel =>
                  amenities.every(amenity => hotel.amenities && hotel.amenities.includes(amenity))
                );
              }
            } catch (amenityFilterError) {
              console.warn('âš ï¸ Amenity filtering error:', amenityFilterError);
            }
            
          } catch (transformError) {
            console.error('âŒ Transformation error:', transformError);
            hotels = [];
          }
        }

        if (isInspectMode) {
          try {
            debugInfo = {
              pipeline: 'two_stage',
              candidateSource: candidateDebugInfo.source,
              candidateParams: {
                url: candidateDebugInfo.url || 'unknown',
                paramsUsed: candidateDebugInfo.paramsUsed || {},
                elapsedMs: candidateDebugInfo.totalElapsedMs || 0,
                status: candidateDebugInfo.attempts?.[0]?.status || 'unknown',
                bodySnippetHead: candidateDebugInfo.attempts?.[0]?.bodySnippetHead || 'no data'
              },
              candidateCount,
              vacancy: {
                chunkSize: 15,
                chunks: vacancyResult?.chunks || []
              }
            };
          } catch (debugError) {
            console.warn('âš ï¸ Debug info creation error:', debugError);
          }
        }
        
      } catch (vacancyError) {
        console.error('âŒ Vacancy check error:', vacancyError);
        hotels = [];
      }
      
    } catch (candidateError) {
      console.error('âŒ Candidate fetch error:', candidateError);
      return jsonResponse(createResponse(
        [],
        false,
        candidateError instanceof Error ? candidateError.message : 'Candidate fetch failed',
        'ç©ºå®¤æ¤œç´¢ã§ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        isInspectMode ? {
          pipeline: 'two_stage',
          error: candidateError instanceof Error ? candidateError.message : 'Unknown candidate error',
          candidateCount: 0,
          vacancy: { chunkSize: 15, chunks: [] }
        } : undefined,
        areaName
      ));
    }

    const totalElapsedMs = Date.now() - startTime;
    console.log(`ğŸ¯ æ¤œç´¢å®Œäº†: ${hotels.length}ä»¶ã®ãƒ›ãƒ†ãƒ« (æ™‚é–“: ${totalElapsedMs}ms)`);

    // æˆåŠŸãƒ¬ã‚¹ãƒãƒ³ã‚¹
    const message = hotels.length > 0 
      ? `${hotels.length}ä»¶ã®ç©ºå®¤ã‚ã‚Šãƒ›ãƒ†ãƒ«ãŒè¦‹ã¤ã‹ã‚Šã¾ã—ãŸ`
      : 'æœ¬æ—¥ã®ç©ºå®¤ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚ã‚¨ãƒªã‚¢ã‚’å¤‰ãˆã¦ãŠè©¦ã—ãã ã•ã„ã€‚';

    return jsonResponse(createResponse(hotels, true, null, message, debugInfo, areaName));

  } catch (error) {
    const errorElapsedMs = Date.now() - startTime;
    console.error('ğŸ’¥ Unhandled error in hotel search:', error);

    // æœ€çµ‚ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆçµ¶å¯¾ã«æˆåŠŸã™ã‚‹ï¼‰
    try {
      const isInspectMode = request?.url ? new URL(request.url).searchParams.get('inspect') === '1' : false;
      return jsonResponse(createResponse(
        [],
        false,
        error instanceof Error ? error.message : 'Unknown system error',
        'ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚',
        isInspectMode ? {
          error: error instanceof Error ? error.message : 'Unknown error',
          elapsedMs: errorElapsedMs
        } : undefined
      ));
    } catch (fallbackError) {
      console.error('ğŸ’¥ Fallback error:', fallbackError);
      // æœ€å¾Œã®ç ¦ï¼šå®Œå…¨ã«é™çš„ãªãƒ¬ã‚¹ãƒãƒ³ã‚¹
      return NextResponse.json({
        items: [],
        paging: { total: 0, page: 1, totalPages: 0, hasNext: false },
        isSample: false,
        fallback: false,
        searchParams: {
          area: 'æ–°å®¿é§…å‘¨è¾º',
          checkinDate: '2025-08-30',
          checkoutDate: '2025-08-31',
          adultNum: 2,
          isVacantSearch: true
        },
        message: 'ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚',
        success: false,
        error: 'Critical system error'
      }, { status: 200 });
    }
  }
}
